### 1 实验目的与要求

- 加深对操作系统设备管理基本原理的认识，实践键盘中断、扫描码等概念；
- 通过实践掌握 Linux 0.11 对键盘终端和显示器终端的处理过程。

### 2 实验环境（软、硬件平台）

蓝桥平台lanqiao.cn

**主要硬件环境**

* IA-32（x86） 架构的 PC 机

**主要软件环境**

* Bochs
* Gcc
* Vim
* Ubuntu 16.04
* Linux 0.11 源代码

### 3 实验内容及步骤

**实验内容：**

本实验的基本内容是修改 Linux 0.11 的终端设备处理代码，对键盘输入和字符显示进行非常规的控制。

在初始状态，一切如常。用户按一次 F12 后，把应用程序向终端输出所有字母都替换为“*”。用户再按一次 F12，又恢复正常。第三次按 F12，再进行输出替换。依此类推。

**实验步骤：**

1. 键盘输入处理过程

2. 输出字符的控制



### 4 实验过程记录

本次实验所要修改的文件均在`~/oslab/linux-0.11/kernel/chr_drv/`目录下。

#### 0x01. 修改keyboard.S

解压好相应文件，进入`~/oslab/linux-0.11/kernel/chr_drv/`目录下，修改`keyboard.S`文件，注意此文件后面的扩展名是大写。

```bash
cd ~/oslab/linux-0.11/kernel/chr_drv/ && vim keyboard.S
```

使用`/func`可快速定位func程序段，找到其最后一行代码，大概在226行，添加如下代码

```c
/*当读到F12的扫描码，就调用switch_star_flag函数*/
call switch_star_flag
```

![image-20200617145011141](%E5%AE%9E%E9%AA%8C%E5%85%AB.assets/image-20200617145011141.png)



#### 0x02. 修改console.c

使用Vim打开`console.c`文件，使用`/con_write`可快速定位到`con_write()`函数，大概在444行。在此函数上面添加下面这段代码。

```c
unsigned long star_flag = 0;
void switch_star_flag(void) {
	if(star_flag) {
		star_flag = 0;
    } else {
		star_flag = 1;
    }
}
```

![image-20200617150437422](%E5%AE%9E%E9%AA%8C%E5%85%AB.assets/image-20200617150437422.png)



接下来往下找几行，插入下面这段代码。修改之后保存退出

```c
if(star_flag) {
    c='*';
}
```

![image-20200617150757913](%E5%AE%9E%E9%AA%8C%E5%85%AB.assets/image-20200617150757913.png)



#### 0x03. 编译运行

```bash
cd ~/oslab/linux-0.11 && make all

../run
```



运行之后，首先输入`ls`命令，字符正常显示，按下F12之后，就显示星号了。字符隐藏可将输出字符变成空格或者为空，这里不再赘述。

![image-20200617151331227](%E5%AE%9E%E9%AA%8C%E5%85%AB.assets/image-20200617151331227.png)



### 5 实验数据分析及小结

**在原始代码中，按下 F12，中断响应后，中断服务程序会调用 func？它实现的是什么功能？**

当按下 F12 以后，会显示出进程的状态，剩余内核栈的空间。

**在你的实现中，是否把向文件输出的字符也过滤了？如果是，那么怎么能只过滤向终端输出的字符？如果不是，那么怎么能把向文件输出的字符也一并进行过滤？**

我的实现中没有将向文件输出的字符过滤。如果想要把向文件输出的字符串也一并过滤，需要修改`/kernel/chr_drv/tty_io.c`文件中的 `copy_to_cooked()`函数。