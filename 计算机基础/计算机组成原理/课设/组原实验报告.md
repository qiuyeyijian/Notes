### 一、课程设计目的

1．巩固《计算机组成原理》这门课程的知识，通过知识的综合运用，使学生加深对计算机系统各模块的工作原理及相互联系的认识，加深计算机工作中“时间-空间”概念的理解，从而清晰地建立计算机的整机概念。

2．学习设计和调试计算机的基本步骤和方法，培养学生独立开展科学研究的工作能力，使学生取得解决计算机领域工程复杂问题时必须的工程实践经验和能力，理解团队工作的责任。培养学生担任团队成员或负责人的角色的能力，培养学生独立完成团队分配的工作的能力。

### 二、课程设计小组情况

| 序号 | 班级  | 学号       |  姓名  | 角色 |                       分工                       |
| :--: | ----- | :--------- | :----: | ---- | :----------------------------------------------: |
|  1   | 计181 | 1813021012 | 张龙威 | 组长 |    硬件设计与实现、指令格式设计、指令周期绘制    |
|  2   | 计181 | 1813021010 |  龙禹  | 组员 |            微指令格式设计、微程序编写            |
|  3   | 计181 | 1813021014 | 潘盛在 | 组员 | 测试程序设计与编写、测试程序与模型机硬件仿真联调 |

### 三、课程设计任务

1．基本设计任务

（1）设计一台微程序控制的模型计算机。

（2）参考给定的数据格式和指令格式，利用所设计的模型机硬件实现课程设计指导书指定的5条指令,并用这5条指令编写能够完成特定功能的测试程序，在Vivado仿真环境下测试程序的运行与调试。

2．选做设计任务

* 无条件跳转指令 **jmp**

* **结果不为0**时跳转指令 **JNZ**

#### 四、课程设计完成条件

一台安装了Vivado软件的计算机。

### 五、课程设计预习报告

#### 1. 模型机电路原理图

模型机的电路图如图1所示，该模型机是CPU内部单总线结构，总线为IBUS[31:0]，外部是三总线结构，其中地址总线ABUS[7:0]，数据总线DBUS[31:0]，控制总线CBUS[1:0]。该电路从上到下，依次为：

* 两个数据数据寄存器DR，用来存放送给ALU计算的两个操作数。

* 运算器ALU，可以完成基本算术运算加减乘除，逻辑运算与或非以及自增自减等。

* 程序状态字寄存器PSWR，用来存放ALU运算输出的各种标志，比如ZF, CF, SF, OF等

* 程序计数器PC, 用来存放下一条指令的地址。

* 指令计数器IR，用来存放要当前执行的指令

* 微程序控制器：包括微地址形成模块μAG，微地址寄存器μAR，微指令寄存器μIR，微指令译码器μIR_DECODER。

* 时序信号产生器，能根据FPGA开发板的内置时钟产生两个周期相同，先后到达的的时钟节拍，主频为50HZ。

* 地址寄存器MAR, 数据寄存器 MDR和由一个512B 的ROM和一个512BRAM, 字长32位， 按字编址

![第三版](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E7%AC%AC%E4%B8%89%E7%89%88.jpg)



#### 2. 指令格式

本次设计任务完成了七条机器指令，指令格式如下

![zhilinggeshi](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/zhilinggeshi.jpg)

寻址特征编码及相应功能说明如下

| 编码 | 寻址说明                           |
| ---- | ---------------------------------- |
| 0000 | 无操作数                           |
| 0001 | 单操作数，立即数寻址               |
| 0010 | 双操作数，寄存器 寻址 - 寄存器寻址 |
| 0011 | 双操作数，寄存器 寻址 - 立即数寻址 |
| 0100 | 双操作数，寄存器寻址 - 直接寻址    |

#### 相关指令编码及功能描述

下面实现了对32条指令的编码，运算器可以完成里面的全部算术运算和逻辑运算指令，本次课设挑选了其中七条指令来进行实验，其余指令方便以后进行功能扩充。

| 汇编指令格式  | 操作码 | 功能描述                                                 |
| :------------ | ------ | -------------------------------------------------------- |
| NOP           | 000000 | 空操作                                                   |
| ADD  DR, SR   | 000001 | DR + SR -> DR                                            |
| SUB  DR, SR   | 000010 | DR - SR -> DR                                            |
| ADC  DR, SR   | 000011 | CF + DR + SR -> DR                                       |
| SBB  DR, SR   | 000100 | DR - SR -CF -> DR                                        |
| MUL  DR, SR   | 000101 | DR \ast SR -> (SR, DR)  (无符号)                         |
| DIV  DR, SR   | 000110 | DR \div SR -> DR  (无符号)                               |
| ADDI  DR, IMM | 000111 | DR + IMM -> DR (立即数和寄存器相加)                      |
| CMP  DR, SR   | 001000 | DR - SR (比较置位，若ZF = 1, 则DR = SR)，CF=1,则 dr < sr |
| AND  DR, SR   | 001001 | DR & SR -> DR (与)                                       |
| OR  DR, SR    | 001010 | DR \| SR ->  DR (或)                                     |
| XOR  DR, SR   | 001011 | DR \bigoplus SR -> DR (异或)                             |
| NOT  DR       | 001100 | ~DR -> DR (非)                                           |
| TEST  DR, SR  | 001101 | DR & SR (测试DR某位是0还是1,通过ZF标志判断)              |
| INC  DR       | 001110 | DR 自增1                                                 |
| DEC  DR       | 001111 | DR 自减1                                                 |
| SHL  DR       | 010000 | 逻辑左移                                                 |
| SHR  DR       | 010001 | 逻辑右移                                                 |
| MOV  DR, SR   | 010010 | SR -> DR                                                 |
| MOVL  DR, IMM | 010011 | IMM -> DR(0-15)                                          |
| MOVH  DR, IMM | 010100 | IMM -> DR(16-31)                                         |
| LOAD  DR, SR  | 010101 | [SR] -> DR                                               |
| STORE  DR, SR | 010110 | SR -> [DR]                                               |
| JMP  DST      | 010111 | 无条件跳转到地址DST，即DST = PC + OFFSET                 |
| JC  DST       | 011000 | CF = 1时，跳转到DST，即DST = PC + OFFSET                 |
| JNC  DST      | 011001 | CF = 0时，跳转到DST，即DST = PC + OFFSET                 |
| JZ  DST       | 011010 | ZF = 1时，跳转到DST，即DST = PC + OFFSET                 |
| JNZ  DST      | 011011 | ZF = 0时，跳转到DST，即DST = PC + OFFSET                 |
| JS  DST       | 011100 | SF = 1时，跳转到DST，即DST = PC + OFFSET                 |
| JNS  DST      | 011101 | SF = 0时，跳转到DST，即DST = PC + OFFSET                 |
| CLC           | 011110 | 进位清0,0 -> CF                                          |
| HALT          | 011111 | 关机                                                     |



#### 3. 指令周期流程图

下面是六条指令的指令周期流程图，第七条是关机指令，执行关机指令后CPU会一直进行空操作，这里不再列出。

![001](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/001.jpg)

#### 4. 微指令格式

微指令格式如下，采用水平型微指令格式，然后采用字段译码方式。

* 下地址有9位， 采用断定方式，可以寻512个存储单元。

* 判别测试字段有3位。

* xx_oe字段有3位，主要控制个别芯片的输出，还有一些互斥指令，比如pc自增信号，主存读信号。

* xx_ce字段有3位，主要是个别芯片的片选信号。

- alu字段有6位，主要是alu运算的功能选择信号。

- mar字段有2位，主要是mar的输入输出控制信号。

- mdr字段有2位，主要是mdr的输入输出控制信号。

- reg_ena字段有4位，主要是寄存器数组的存数和取数控制信号。



![geshi](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/geshi.jpg)



### 六、课程设计报告

#### 1. 模型机完整数据通路仿真电路

下

![image-20200701184222496](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20200701184222496.png)



#### 2. 微程序

本次设计的指令系统包括7条指令，实现每条指令的的微程序如下：

##### 取指微指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0000               | 00               | 01                | 000000          | 000                   | 001                   | 000               | 000000001   |
| 0000               | 10               | 10                | 000000          | 001                   | 101                   | 000               | 000000010   |
| 0000               | 00               | 00                | 000000          | 000                   | 010                   | 001               | 000000000   |

##### load 指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0101               | 00               | 01                | 000000          | 000                   | 000                   | 000               | 000000100   |
| 0010               | 10               | 10                | 000000          | 001                   | 101                   | 000               | 000000000   |

##### store 指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0110               | 00               | 01                | 000000          | 000                   | 000                   | 000               | 000000110   |
| 0001               | 01               | 10                | 000000          | 111                   | 000                   | 000               | 000000000   |

##### mov 指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0001               | 00               | 00                | 000000          | 000                   | 100                   | 000               | 000000000   |

##### cmp 指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0101               | 00               | 00                | 000000          | 100                   | 001                   | 000               | 000001001   |
| 0000               | 00               | 00                | 000000          | 101                   | 100                   | 000               | 000001010   |
| 0000               | 00               | 00                | 001000          | 011                   | 010                   | 001               | 000000000   |

##### jmp指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0000               | 00               | 00                | 000000          | 110                   | 100                   | 000               | 000000000   |



##### add 指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0101               | 00               | 00                | 000000          | 100                   | 000                   | 000               | 000001101   |
| 0000               | 00               | 00                | 000000          | 101                   | 100                   | 000               | 000001110   |
| 0001               | 00               | 00                | 000001          | 011                   | 011                   | 000               | 000000000   |



##### halt关机指令

| 寄存器控制信号 4位 | MDR控制信号  2位 | MAR 控制信号  2位 | ALU控制信号 6位 | 其他芯片选择信号  3位 | 其他芯片输出信号  3位 | 判别测试字段  3位 | 下地址 9 位 |
| ------------------ | ---------------- | ----------------- | --------------- | --------------------- | --------------------- | ----------------- | ----------- |
| 0000               | 00               | 00                | 000000          | 000                   | 000                   | 000               | 111111111   |
| 0000               | 00               | 00                | 000000          | 000                   | 000                   | 000               | 111111110   |



#### 3. 测试程序

用所设计的7条指令编写的测试程序如下，该测试程序从1开始累加，如果累加和为100，就以100为地址，从主存里面取出一个数X，然后以X为地址，将100存入到主存里。

其中MOV, ADD, CMP都是 寄存器 - 立即数寻址。JNZ为立即数寻址，立即数为地址偏移量。

| 测试程序助记符代码 | 测试程序机器代码                    |
| ------------------ | ----------------------------------- |
| MOV R0, 1          | 010010_0011_000000_0000000000000001 |
| ADD R0,  1         | 000001_0011_000000_0000000000000001 |
| CMP R0, 100        | 001000_0011_000000_0000000001100100 |
| JNZ  3             | 011011_0001_000000_1000000000000011 |
| LOAD R1, R0        | 010101_0010_000001_0000000000000000 |
| STORE R1, R0       | 010110_0010_000001_0000000000000000 |
| HALT               | 011111_0000_000000_0000000000000000 |



#### 4. 测试程序与模型机联调过程及结果

![image-20200701194721253](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20200701194721253.png)



1. 首先将测试程序每条指令结合之前设计的指令编码，将每条指令存入到主存的ROM中。微程序的控制存储器也存入相关指令的微程序。

2. 仿真开始，执行rst复位信号， CPU开始进入取指周期，取指微程序的入口地址就是9'b000000000。
3. CPU内部有一个时序信号生成器，会将输入的时钟信号分成两个周期相同的节拍脉冲cp0、cp1。
4. 每当在cp0上升沿时，就将微地址形成器μAG形成的微指令地址存入到微地址寄存器μAR。每当在cp1上升沿时，就将控制存储器CM输出的微指令信号存入到微指令寄存器μIR，然后输入到微指令译码器μIR_DECODER里进行译码输出。
5. 仿真波形图中，在30ns, 70ns, 110ns时，cp0是上升沿，将微地址形成器μAG形成的微地址存入到微地址寄存器μAR。
6. 在10ns, 50ns, 90ns时，cp1是上升沿，将从控制存储器CM取出的微指令存入到微指令寄存器μIR中。
7. 每当有指令存入到μIR中，微指令译码器μIR_DECODER就将微指令进行字段译码，输出操作控制信号。
8. CPU循环进行这样的取指执行操作，会持续运行测试程序直到结束。遇到halt关机指令之后，CPU会一直进行空操作。



#### 5. 设计说明及工作小结

##### 设计想法和创新

进行本次设计之前，首先分析了想要实现的功能指令在CPU内部的执行过程。然后根据实验指导书画出模型机的数据通路。

根据想要实现的指令，考虑到之后的扩展，设计了指令格式。比较有自己想法的是：

1. **寻址特征设置了四位**。这样就有足够的编码来表示后面两个操作数的寻址特征，这样只需要设计一个指令格式就可以进行双操作数，单操作数和无操作数的运算。
2. **源操作数设计时给了16位**。这样不仅可以进行寄存器寻址，同时也可以进行立即数寻址。同时16正好是32的二分之一，统一了立即数的位数，方便之后的编程和记忆。

数据通路和指令格式设计好之后，就开始设计微指令格式。CPU内部采用了单总线结构，所以必须可以精确地控制各个芯片。所以每个芯片都有两个基本的控制信号ce是对应芯片选中信号，oe是对应芯片输出控制信号。

这样只要ce或者oe没有信号，这个芯片就处于高阻态，就仿佛没有这个芯片，不会对总线产生影响。

如果采用全水平型微指令，控制信号远远超过32位，所有必须采用字段译码方式。将互斥信号放在一起编码可以大大缩短微指令长度。进行设计时比较有自己想法的是：

1. **输出控制信号尽可能放一起**。因为CPU内部采用单总线结构，所以一般输出控制信号oe应该是互斥的，可以放在一起编码。
2. **部件的功能操作信号可以放在一起**。因为每个部件在同一时刻，只能进行一种功能操作。所以信号应该也是互斥的。
3. **下地址采用了9位**。可以寻512个存储单元，这样控制存储器除了可以存储基本的功能 ，可以方便之后有足够的空间进功能扩展。

##### 问题和解决方法

**问题一：立即数寻址**

设计指令格式时，最开始是设计了两个寻址特征位，第一个寻址特征位负责目的操作数的寻址方式，第二个寻址特征位负责源操作数的寻址特征位。

![image-20200702022143336](assets/%E7%BB%84%E5%8E%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20200702022143336.png)

**问题二：**

微程序的入口地址我是和微程序放在一起的，之后如果要修改编码或者增加指令就会变得很麻烦，牵一发而动全身。经过老师指出，我有种忽然顿悟的感觉。老师之前也说了，微程序入口地址是放在一块连续的地址空间的。

在控制存储器留出足够的用来存储微程序入口地址空间，其他空间就可以存放微程序其他部分。这样添加和修改就很方便。

### 七、总结与体会

本次课程设计从开始到完成设计报告，经历了大概一周的时间。最大的感触是遇到问题应该多和同伴沟通，只有经过思想的碰撞才能共同进步。

另一个较大的感触是组成原理无论是之前的实验，还是这个课设在开始用Verilog HDL进行描述电路之前一定要进行电路原理图设计，并弄清楚数据通路各部件是怎样协调工作的。

我在这方便深有体会的原因是课程设计之前，我只设计好指令格式和指令周期流程图就开始了代码的编写，后来由于考虑不周，漏掉了一两个关键的控制信号。或者同一个相容的信号放在了同一个控制字段中。这就在修改代码方便浪费了很多时间。

在设计微程序控制存储器时，我由于没有考虑老师给的建议，就将微程序入口地址和微程序其他部分放在了一起。这样也对后来加入，删除或移动某个微程序位置造成了诸多不便。

不过最后经过需求老师帮助，和同伴沟通，模型机可以实现运转了。

### 八、参考文献

[1]鲍可进,赵念强,赵不贿.数字逻辑电路设计[M].清华大学出版社:北京,2015:331.

[2]白中英,戴志涛.计算机组成原理[M].科学出版社:北京,2019:1.

[3]汇编语言程序设计教程.陆遥[M].清华大学出版社:北京,2018:1.s