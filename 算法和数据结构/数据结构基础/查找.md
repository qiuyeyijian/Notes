# 查找



### 二分查找

```cpp
// arr:  要查找的数组
int binarySearch(int arr[], int left, int right, int data) {

    while (left <= right) {
        // 获取中间下标
        // 这样做比 （left + right）/ 2 更安全，可以避免int溢出
        int mid = left + (right - left) / 2;
        if (arr[mid] == data) {
            // 查找成功，返回下标
            return mid;
        }
        else if (arr[mid] > data) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }

    // 查找失败
    return -1;
}
```



### 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

根据顺序表二分法查找比较次数的计算公式：
$$
a<log_2n<b (a,b,n \in Z^+)
$$
当顺序表有n个关键字时：

查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。

如果顺序表记录数 n=97 ，log₂64<log₂97<log₂128，即6<log₂97<7，最大比较次数为7次。

### 分块查找

分块查找的平均查找长度不仅取决于数据集的总记录个数 n，还和每一块的记录个数 t 相关。



### 二叉排序树

> 二叉排序树（Binary Sort Tree），又称二叉查找树。它或者是一颗空树，或者是具有以下性质的二叉树。
>
> * 若它的左子树不空，则左子树上所有的节点的值均小于它的根结点的值；
> * 若它的右子树不空，则右子树上所有的节点的值均大于它的根结点的值；
> *  ⑶ 左、右子树本身又各是一棵二叉排序树。 按中序遍历二叉排序树，所得到的中序遍历序列是一个递增有序序列   

### 平衡二叉树（AVL树）

> 平衡二叉树（Height-Balanced Binary Search Tree），是一种二叉排序树，其中的每一个节点的左子树和右子树的高度差至多等于1。
>
> 我们将二叉树上节点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor)

### 散列表查找



对于散列表长为m的散列函数，构造方法有：

1. 除留余数法

> Hash(key) = key mod p (p<=m)

p一般取小于m的最大质数（素数）

2. 直接定址法

$$
Hash(key) = a\times key + b \quad \left( a, b 为常数 \right)
$$

3. 数字分析法
4. 平方取中法
5. 折叠法
6. 随机数法



Hash表的平均查找长度与处理冲突的方法和散列表的装填因子有关

* 装填因子 = 填入表中的记录个数 / 散列表长度。



 查找成功=查找次数/数据个数。

查找失败=查找次数/散列后的地址个数。