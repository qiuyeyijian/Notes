# 入门训练



### BEGIN-1 A+B问题

> **问题描述**
>
> 输入A、B，输出A+B。
>
> **输入格式**
>
> 输入的第一行包括两个整数，由空格分隔，分别表示A、B。
>
> **输出格式**
>
> 输出一行，包括一个整数，表示A+B的值。

```c
// 样例输入
12 45
    
// 样例输出
57
    
// 数据规模与约定
-10000 <= A, B <= 10000。
```

**参考源代码**

```c++
#include<iostream>
using namespace std;

int main() {
	int a, b;
	
	cin >> a >> b;
	cout << a+b << endl;

	return 0;
}
```



### BEGIN-2 序列求和

> **问题描述**
>
> 求1+2+3+...+n的值。
>
> **输入格式**
>
> 输入包括一个整数n。
>
> **输出格式**
>
> 输出一行，包括一个整数，表示1+2+3+...+n的值。

```c
// 样例输入
100
    
// 样例输出
5050
    
// 数据规模与约定
1 <= n <= 1,000,000,000
```

**参考源代码**

```c++
#include<iostream>

using namespace std;

int main() {
	// 数据规模与约定设置long long int类型 
	long long int n;
	
	cin >> n; 
	// 时间复杂度为O(1), 避免使用for循环
	cout << (n + 1) * n / 2 << endl;
	
	return 0;
}
```





### BEGIN-3 圆的面积

> **问题描述**
>
> 给定圆的半径r，求圆的面积。
>
> **输入格式**
>
> 输入包含一个整数r，表示圆的半径。
>
> **输出格式**
>
> 输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。

```c
// 样例输入
4
    
// 样例输出
50.2654825
    
// 数据规模与约定
1 <= r <= 10000
    
//提示
本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4， 但要包含math.h头文件。
```

**参考源代码**

```c++
#include<iostream>
#include<iomanip>
#include<stdio.h>
using namespace std;

int main() {
	int r;
	double PI = 3.14159265358979323;
	
	cin >> r;
	
	printf("%.7f", PI * r * r);
	//cout << setprecision(9) << PI * r * r << endl;
	
	return 0;
} 
```





### BEGIN-4 Fibonacci数列

> **问题描述**
>
> Fibonacci数列的递推公式为：F(n)=F(n-1)+F(n-2)，其中F(1)=F(2)=1。
>
> 当n比较大时，F(n)也非常大，现在我们想知道，F(n)除以10007的余数是多少。
>
> **输入格式**
>
> 输入包含一个整数n。
>
> **输出格式**
>
> 输出一行，包含一个整数，表示Fn除以10007的余数。

| 样例输入 | 样例输出 |
| -------- | -------- |
| 10       | 55       |
| 22       | 7704     |

```c
// 数据规模与约定
1 <= n <= 1,000,000
    
//提示
在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。
```

**参考源代码**

```c++
#include<iostream>

using namespace std;

void func(int n) {
	int f1 = 1;
	int f2 = 1;
	int temp = 0;
	
	if(n <= 2) {
		cout << 1;
	} else {
		for (int i = 3; i <=n; i++) {
			// 必须边计算，边取模，防止超过问题规模 
			temp = (f1 + f2) % 10007;
			f1 = f2;
			f2 = temp;
		}
		// 如果n很大，f2的长大小可能会超过问题规模，
		// 所以不能在最后统一取模10007，会报错，这是一个坑 
		cout << f2;
	}	
}

int main() {
	int n;
	
	cin >> n;
	
	func(n);
	
	return 0;
}
```







