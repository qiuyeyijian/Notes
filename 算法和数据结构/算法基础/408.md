# 408算法题



## 2000年

### 算法思想



### C++ 描述



### 时间和空间复杂度





## 2010年

### 算法思想

对数组进行三次逆置

1. 先将整个数组[0，n-1)逆置一遍；
2. 将数组的前部分区间[0，p-1)进行逆置；
3. 将数组的后部分区间[p，n-1)进行逆置；

### C++描述

```cpp
void reverse(int* arr, int start, int end) {
  int temp = 0;
  // 交换前后对应元素实现逆置
  while (start != end && start < end) {
    temp = arr[start];
    arr[start++] = arr[end];
    arr[end--] = temp;
  }
}

void solve(int* arr, int len, int p) {
  //将整个数组逆置
  reverse(arr, 0, len - 1);
  // 将数组前p个元素逆置
  reverse(arr, 0, p - 1);
  // 将数组后n-p个元素逆置
  reverse(arr, p, len - 1);
}
```



### 时间和空间复杂度

时间复杂度为：$O(n)$

空间复杂度为：$O(1)$



## 2011年

### 算法思想

```
解题思路：O（logn）的解
分别求两个升序序列的 A、B 的中位数 a 和 b，
① 若 a = b, 则已找到两个序列的中位数，返回a
② 若 a < b, 则舍弃序列 A 中较小的一半， 舍弃序列 B 中较大的一半
③ 若 a > b, 则舍弃序列 A 中较大的一半， 舍弃序列 B 中较小的一半 重复过程 ① 到 ③ 直到两个序列均只含一个元素为止，返回较小者。
```

### C++ 描述

```cpp
// 时间复杂度O(n)，空间复杂度O(1)
int solve(int* arr1, int* arr2, int len) {
  int p = 0, q = 0;  // 两个序列的下标
  // 只需比较len-1次
  for (int i = 0; i < len - 1; ++i) {
    arr1[p] > arr2[q] ? q++ : p++;
  }
  // 返回二者当中较小的，就是中位数
  return arr1[p] > arr2[q] ? arr1[q] : arr2[p];
}
```



```cpp
// 时间复杂度O(logn)，空间复杂度O(1)
int midNum(int* a, int* b, int n) {
  int s1 = 0, d1 = n - 1, s2 = 0, d2 = n - 1;
  int m1, m2;

  while (s1 != d1 || s2 != d2) {
    m1 = (s1 + d1) / 2;
    m2 = (s2 + d2) / 2;

    if (a[m1] == b[m2]) {
      return a[m1];
    } else if (a[m1] < b[m2]) {
      if ((s1 + d1) % 2 == 0) {  // 元素个数为奇数
        s1 = m1;                 // 保留中间点
        d2 = m2;                 // 保留中间点
      } else {                   // 元素个数为偶数
        s1 = m1 + 1;             // 不保留中间点
        d2 = m2;                 // 保留中间点
      }
    } else {
      if ((s2 + d2) % 2 == 0) {  // 元素个数为奇数
        s2 = m2;                 // 保留中间点
        d1 = m1;                 // 保留中间点
      } else {                   // 元素个数为偶数
        s2 = m2 + 1;             // 不保留中间点
        d1 = m1;                 // 保留中间点
      }
    }

  }  // end of while

  return (a[s1] < b[s2]) ? a[s1] : b[s2];
}
```

### 时间和空间复杂度

时间复杂度为：$O(logn)$

空间复杂度为：$O(1)$





## 2013年

### 算法思想

创建一个辅助数组t，大小为n，模拟map。

遍历所给数组arr，由于数组arr中各元素值均不大于n。则用arr元素值作为数组t的下标，统计所有元素出现次数。

最后选取次数最高元素，进行比较判断。

### C++ 描述

```cpp
// 时间复杂度O(n)，空间复杂度O(n)
void solve(int* arr, int len) {
  // 创建大小为n的辅助空间
  int* t = new int[len]{0};
  int ans = 0;

  // 统计各元素出现次数
  for (int i = 0; i < len; ++i) {
    t[arr[i]]++;
  }

  // 寻找出现次数最高的元素
  for (int i = 0; i < len; ++i) {
    if (t[i] > ans) ans = t[i];
  }

  printf("%d\n", ans > len / 2 ? ans : -1);
  delete t;
}
```

```cpp
//摩尔投票法思想：如果某元素是主元素的话，
//那么他与剩下的其他元素一一抵消的话他也会胜出
//时间复杂度O(n)，空间复杂度O(1)
void moleVote(int* arr, int len) {
  // 选择第一个元素作为临时主元，计数器初始化1
  int ans = arr[0], count = 1;
  for (int i = 1; i < len; ++i) {
    // 如果遇到的元素和临时主元相等，计数器加1，否则抵消减1
    ans == arr[i] ? count++ : count--;

    // 如果计数器为0，则选择当前元素为新的主元
    if (count == 0) {
      ans = arr[i];
      count++;
    }
  }

  count = 0;
  // 统计最后剩下来的临时主元出现次数
  for (int i = 0; i < len; ++i) {
    if (ans == arr[i]) count++;
  }

  printf("%d\n", count > len / 2 ? ans : -1);
}
```



### 时间和空间复杂度

时间复杂度为：$O(n)$

空间复杂度为：$O(1)$























