## 第五章作业



### 5-01

运输层处于面向通信部分的最高层，同时也是用户功能中的最低层，向他上面的应用层提供服务; 

  **运输层**为**应用进程之间提供端到端的**逻辑通信,但**网络层是为主机之间**提供逻辑通信(面向主机，承担路由功能，即主机寻址及有效的分组交换). 

  各种应用进程之间通信需要“可靠或尽力而为”的两类服务质量，**必须由运输层以复用和分用的形式加载到网络层**。



### 5-02

不会影响运输层的运行机制，但是会影响服务质量。

### 5-04

![504](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/504.png)

### 5-05

SNMP，DNS，DHCP，TFTP

### 5-08

**UDP是面向报文的**：发送方的UDP对应用程序交下来的报文，在添加了首部之后就向下交付，UDP对应用层交付下来的报文即不合并也不拆分，而是保留这些报文的边界，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，接收方UDP对下方交上来的UDP用户数据报，在去除首部之后就原封不动的交付给上层的应用程序，一次交付一个完整报文，所以是UDP是面向报文的

**TCP是面向字节的**：发送方TCP对应用程序交下来的报文数据块，视为无结构的字节流（无边界约束，可拆分/合并），但维持各字节流顺序（相对顺序没有变），TCP发送方有一个发送缓冲区，当应用程序传输的数据块太长，TCP就可以把它划分端一些再传输，如果应用程序一次只传输一个字节，那么TCP可以等待积累足够多的字节后再构成报文端发送出去，所以TCP的面向字节的

### 5-09

**端口的作用是对TCP/IP体系的应用进程进行统一的标志，使运行不同操作系统的计算机能够相互通信。**

熟知端口号：数值一般为0~1023，标记常规的服务进程如FTP是21，DNS是53,HTTP是80，SMTP是25，POP3是110等

登记端口号：数值为1024~49151，标记没有熟知端口号的非常规的服务进程

短暂端口号：数值为49152~65535，客户进程运行时动态选择

### 5-10

仅用于计算运输层数据报的校验和

### 5-13

![13](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/13.jpg)



### 5-14

![14](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/14.jpg)



### 5-16

不行，分组和确认都必须进行编号，才能明确那个分组被正确接收。停止等待协议是TCP可靠传输的保证之一。

### 5-19

![519](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/519.jpg)



### 5-21

![21](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/21.jpg)

![212](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/212.jpg)

### 5-23

![23](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/23.jpg)



### 5-25

在ICMP的差错报文中要包含IP首部后面8个字节的内容，而这里面有TCP首部中的源端口和目的端口，当TCP收到ICMP差错报文时需要用这两个端口来确定是哪条连接出了差错



### 5-27， 5-28

![2728](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/2728.jpg)



### 5-37

慢开始：在主机刚刚开始发送报文段时先将拥塞窗口cwnd设置为一个最大报文段的MSS数值，在每收到一个对新的报文端的确认后，将拥塞窗口增加至多一个MSS数值，用这样的方法逐步增大发送端的拥塞窗口cwnd，即逐步增加发送窗口的大小，可以分组注入到网络中的速率更加合理

拥塞避免：当拥塞窗口值（现在是等于发送窗口大小）大于慢开始门限时，停止使用慢开始算法，而改用拥塞避免算法：使发送的拥塞窗口每经过一个往返时延RTT就增加一个MSS的大小

快重传算法：发送端只要连续收到三个重复的ACK，就断定有分组丢失了，就理解重传丢失的报文段而不是等待该报文段的超时计时器超时

快恢复算法：当发送端连续收到三个重复的ACK时，就重新设置慢开始门限ssthresh（当前拥塞窗口的一半）与慢开始不同之处在于拥塞窗口cwnd不是设置为1，而是设置为新的慢开始启动门限（当前拥塞窗口的一半）

乘法减小：是指无论在慢开始阶段还是在拥塞避免阶段，只要出现超时（即很有可能出现了网络拥塞），就是把慢开始门限值ssthresh设置为当前拥塞窗口值的一半，当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数

加法增大：是值指向拥塞避免算法之后，在收到度所有报段的确认后（即经过一个往返时间）就把拥塞控制窗口cwnd增加一个MSS大小，使得拥塞窗口缓慢增大，以防止网络过早的出现拥塞

### 5-38

![image-20201122153456712](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20201122153456712.png)

1 2 4 8 9 10 11 12 1 2 4 6 7 8 9

ssthresh在12之后变成了6，然后又是从1开始，快到6就采用拥塞控制

### 5-39

![image-20201122154705530](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20201122154705530.png)



1， 2， 3 题如图所示

4. 第16轮次，通过收到三个重复确认，第22轮次通过超时

5. | 轮次 | 门限 ssthresh |
   | ---- | ------------- |
   | 1    | 32            |
   | 18   | 21            |
   | 24   | 13            |

6. 第70报文段在第7轮次发送出

7. 拥塞窗口cwnd和门限值应设置为8的一般，即4

### 5-42

如果B不在发送数据，那么是可以将两个报文段合并成一个的。但是如果B之后还要发送数据，而且需要一段时间，那么A就会超时重传FIN信号。浪费网络资源。

### 5-46

如果是使用两次报文握手，可能会存在以下几个问题：

首先看请求建立连接报文因堵塞导致很长一段时间才到达。如果A发送给B的请求连接因网络堵塞在某个地方，那么A会超时重新发送建立连接报文。之后如果之前的请求连接报文到达了B，那么B会误认为A想建立连接，从而在给这个连接分配资源，但是事实是A并没有连接请求。就会浪费B的资源。

再看确认建立链接报文丢失。如果B收到A的连接请求，并发送了确认分组。那么B认为该连接已经建立，可是A并不清楚B是否收到了连接请求。所以会忽视掉B所发送的所有分组，可是如果B没有收到A的确认，会认为发送的分组丢失并重新发送数据，这就导致了死锁。

### 5-49

1. 52100
2. 13
3. 28
4. 20
5. 客户机 -> 服务器
6. Daytime

### 5-59，5-60

![560](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/560.png)

### 5-61

![image-20201122162308917](assets/%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/image-20201122162308917.png)