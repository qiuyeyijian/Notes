## 期末考试总结



### 0x01. 原码， 反码， 补码， 变补

#### 1. 原码

> 正数符号位用 0 表示， 负数符号位用 1 表示

 +1010 => 01010			-1010 => 11010

#### 2. 反码

> 正数：原码=反码=补码
>
>  负数：符号位不变， 其余位按位取反

 -1010 => 反码：10101

 +1010 => 反码=原码：01010

#### 3. 补码

>  正数：原码=反码=补码
>
>  负数：$[x]_反$ + 1;
>
>  负数的反码还可以这样求：符号位和从右到左遇到的第一个1不变，其余位按位取反

* x=-1010

  原码 => 11010

  反码 => 10101
  
   补码 => 10110

#### 4. 补码 => 原码

> 原码 => $[补码]_补$ 

补码的补码就是原码

#### 5. 变补

> 变补就是在原来符号位的基础上再增加一位来表示符号位，也就是两个符号位

* x=-1010

  补码：`1`0110

  变补：`11`0110

> 00：结果为正
>
> 01：上溢
>
> 10：下溢
>
> 11：结果为负



### 0x02. 定点数，浮点数

#### 1. 定点数

> 定点数可以用来表示纯整数和纯小数，其中纯小数的范围在` (-1，1)`之间

简单来说，整数后面加个小数点就是定点数：`1010.`

在` (-1，1)` 之间的纯小数：`0.1111`

1.000111 等就不是纯小数



#### 2. 浮点数

> 计算机中可以这样表示数据：把一个数的有效数字和数的范围在计算机的存储单元中中分别予以表示·，这种把数的范围和精度分别表示的方法相当于小数点的位置随比例因子的不同而在一定范围内可以自由浮动，所以称为浮点表示法。

任意一个十进制数N可以写成
$$
N = 10^E.M
$$


同样，在计算机中一个任意二进制数N可以写成
$$
N = 2^e.M
$$
其中 M 称为浮点数的`尾数`， 是一个纯小数。e 是比例因子的指数，称为浮点数的`指数`, 是一个整数。比例因子的`基数`对二进制纪数值是一个常数

按IEEE754标准，32位浮点数和64位浮点数的标准格式为

* 32位浮点数

|    s    |    E    |    M     |
| :-----: | :-----: | :------: |
| 1位阶符 | 8位阶码 | 23位尾数 |

* 64位浮点数

|    s    |    E     |    M     |
| :-----: | :------: | :------: |
| 1位阶符 | 11位阶码 | 52位尾数 |



**IEEE754标准中，一个规格化的32位浮点数X的真值可以表示为**：
$$
X=（-1）^S\ast（1 . M）\ast2^{E-127}
$$

尾数M表示浮点数的精度，阶码e表示浮点数的范围。

其中有个默认的1在整数部分，在计算机中是没有储存的，凡是IEEE754规格化浮点数都是默认整数部分为1，也叫隐含的1。其中，s取0或1，取0时，表示一个正浮点数，取1时，表示一个负浮点数。

特别地，阶码全0和阶码全1用作了两个特殊用途。

* 当阶码全0，尾数也全部为0（8个0）的时候，表示X为0，再结合符号位S，有+0和-0之分。
* 当阶码全1，尾数全0（8个1，255）的时候表示无穷，同样也有+∞和-∞之分。

所以阶码E能表示的有效范围为1 ~ 254。指数e能表示的范围为E-127，也就是-126 ~ +127



### 0x03. 定点原码一位乘法

假设x,y均为原码表示，计算
$$
x\ast y
$$


运算规则：

1. 先解决结果符号位：$x_f \bigoplus y_f$  , 即x的符号位和y的符号位相异或，就是结果的符号。接下来的计算就不用考虑x和y的符号了。
2. 先设部分积 Z = 0
3. 看乘数 y 的 最低位
   * 若是1 ：$Z + [|x|]_{变补}$
   * 若是0 ：$Z+0$

4. 部分积Z右移一位
5. 重复3，4 不断处理y的每一位，直到y的所有位都处理过为止



![TIM图片20200328221820](README.assets/TIM%E5%9B%BE%E7%89%8720200328221820.jpg)



定点原码一位乘法算出的是$x\ast y$ 的原码，符号需要根据 $x_f \bigoplus y_f$  来判断，

定点补码一位乘法算出的是$x\ast y$ 的补码



### 0x04. 定点原码一位除



**具有n位尾数的合法除法，需要逻辑移位n次，上商n+1次**

算法步骤：

1. 符号位单独处理，分别取除数和被除数绝对值进行运算（和原码两位乘一样，参与运算的是绝对值的补码）

2. 若余数（被除数）为正，表示够减，商上1，左移一位，加上$[-|y|]_变$ 。若余数（被除数）为负，表示不够减，商上0，恢复余数（加上除数），左移一位，加上$[-|y|]_变$

3. 重复上一步骤n次（需设置一个计数器）
4. 若最后一步余数为负，需要恢复余数，否则不需要



![TIM图片20200329102222](README.assets/TIM%E5%9B%BE%E7%89%8720200329102222.jpg)





### 中央处理器



#### 运算器的基本结构



#### 控制器的基本结构

**程序计数器：** 用于